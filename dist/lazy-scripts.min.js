/*! LazyScripts - v0.0.1 - 2019-05-05
* https://lazyscripts.raoulkramer.de
* Copyright (c) 2019 Raoul Kramer; Licensed GNU General Public License v3.0 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):((e=e||self).pkg=e.pkg||{},e.pkg.name=t())}(this,function(){"use strict";return window.NodeList&&!NodeList.prototype.forEach&&(NodeList.prototype.forEach=function(e,t){t=t||window;for(var n=0;n<this.length;n++)e.call(t,this[n],n,this)}),
/**
   * LazyScripts
   * a lazy loader for your javascripts
   * @param {Object} customOptions - define your lazy-script-data selectors
   */
function(){var e=function(o){for(var e=1;e<arguments.length;e++){var c=null!=arguments[e]?arguments[e]:{},t=Object.keys(c);"function"==typeof Object.getOwnPropertySymbols&&(t=t.concat(Object.getOwnPropertySymbols(c).filter(function(e){return Object.getOwnPropertyDescriptor(c,e).enumerable}))),t.forEach(function(e){var t,n,r;t=o,r=c[n=e],n in t?Object.defineProperty(t,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[n]=r})}return o}({lazyScriptSelector:"[data-lazy-script]",lazyScriptsSelector:"[data-lazy-scripts]"},0<arguments.length&&void 0!==arguments[0]?arguments[0]:{}),n="",r="",o=[],c=document.querySelectorAll("".concat(e.lazyScriptSelector,", ").concat(e.lazyScriptsSelector));
/**
     * convert the `querySelectorAll` compatible class options of lazySelectors
     * and return a string, you can use in `dataset[string]`
     * @see https://stackoverflow.com/a/6661012
     * @param {String} string - the text you want to convert
     * @return {String}
     */
function i(e){return e.replace("[data-","").replace("]","").replace(/-([a-z])/g,function(e){return e[1].toUpperCase()})}
/**
     * store all `<script src="â€¦"></script>` scripts
     * to know that they are available and don't need to
     * be loaded again
     */
/**
     * create a `<script>` element, add type, defer and src attribute
     * and append it into the lazyElement
     * @param {Array} scriptsSrc - Array with full paths to js files
     * @param {HTMLElement} element - element the script will be append to
     */
function a(e,t){var n=e.shift();if(n&&-1===o.indexOf(n)){var r=document.createElement("script");o.push(n),r.type="text/javascript",r.src=n,0<e.length&&(r.onload=function(){a(e,t)}),t.appendChild(r)}else 0<e.length&&a(e,t)}
/**
     * callback from fallback or intersectionObserver method,
     * to process both data attributes from given element and
     * load its scripts
     * @param {HTMLElement} lazyElement - the element which entered
     *    the viewport and will be processed
     */function s(e){
// process single script data attribute
e.dataset[n]&&a([e.dataset[n]],e),a(JSON.parse(e.dataset[r]||"[]"),e)}
/**
     * if no IntersectionObserver (and no polyfill) is found,
     * all scripts are gonna be loaded in a batch
     */function u(){c.forEach(function(e){return s(e)})}
/**
     * check every entry if it is `isIntersecting` and load
     * its scripts.
     * when scripts are loaded, the element will be removed from
     * IntersectionObserver
     * @param {Array} entries - IntersectionObserver entry array
     * @param {IntersectionObserver} observer - the IntersectionObserver itself
     */!
/**
     * setup IntersectionObserver (if available)
     * or start loading all scripts within a `requestAnimationFrame`
     * callback - if available
     */
function(){if(document.querySelectorAll("script").forEach(function(e){o.push(e.src)}),n=i(e.lazyScriptSelector),r=i(e.lazyScriptsSelector),window.IntersectionObserver){var t=new IntersectionObserver(function(e,t){return function(e,t){e.forEach(function(e){e.isIntersecting&&(s(e.target),t.unobserve(e.target))})}(e,t)},e.intersectionObserverOptions);c.forEach(function(e){t.observe(e)})}else window.requestAnimationFrame?window.requestAnimationFrame(function(){return u()}):u()}()}});
