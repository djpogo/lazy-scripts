/*! LazyScripts - v0.0.1 - 2019-05-03
* https://lazyscripts.raoulkramer.de
* Copyright (c) 2019 Raoul Kramer; Licensed GNU General Public License v3.0 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):((e=e||self).pkg=e.pkg||{},e.pkg.name=t())}(this,function(){"use strict";return function(){var e=function(c){for(var e=1;e<arguments.length;e++){var o=null!=arguments[e]?arguments[e]:{},t=Object.keys(o);"function"==typeof Object.getOwnPropertySymbols&&(t=t.concat(Object.getOwnPropertySymbols(o).filter(function(e){return Object.getOwnPropertyDescriptor(o,e).enumerable}))),t.forEach(function(e){var t,n,r;t=c,r=o[n=e],n in t?Object.defineProperty(t,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[n]=r})}return c}({lazyScriptSelector:"[data-lazy-script]",lazyScriptsSelector:"[data-lazy-scripts]"},0<arguments.length&&void 0!==arguments[0]?arguments[0]:{}),t=o(e.lazyScriptSelector),n=o(e.lazyScriptsSelector),c=[],r=document.querySelectorAll("".concat(e.lazyScriptSelector,", ").concat(e.lazyScriptsSelector));
/**
     * convert the `querySelectorAll` compatible class options of lazySelectors and
     * return a string, you can use in `dataset[string]`
     * @see https://stackoverflow.com/a/6661012
     * @param {String} string - the text you want to convert
     */
function o(e){return e.replace("[data-","").replace("]","").replace(/-([a-z])/g,function(e){return e[1].toUpperCase()})}
/**
     * store all `<script src="â€¦"></script>` scripts
     * to know that they are available and don't need to
     * be loaded again
     */
/**
     * create a `<script>` element, add type, defer and src attribute
     * and append it into the lazyElement
     * @param {Array} scriptsSrc - Array with full paths to js files
     * @param {HTMLElement} element - element the script will be append to
     */
function i(e,t){var n=e.shift();if(n&&-1===c.indexOf(n)){var r=document.createElement("script");c.push(n),r.type="text/javascript",r.src=n,0<e.length&&(r.onload=function(){i(e,t)}),t.appendChild(r)}else 0<e.length&&i(e,t)}
/**
     * callback from fallback or intersectionObserver method,
     * to process both data attributes from given element and
     * load its scripts
     * @param {HTMLElement} lazyElement - the element which entered the viewport and will be processed
     */function a(e){
// process single script data attribute
e.dataset[t]&&i([e.dataset[t]],e),i(JSON.parse(e.dataset[n]||"[]"),e)}
/**
     * if no IntersectionObserver (and no polyfill) is found,
     * all scripts are gonna be loaded in a batch
     */function u(){r.forEach(function(e){return a(e)})}
/**
     * check every entry if it is `isIntersecting` and load
     * its scripts.
     * when scripts are loaded, the element will be removed from
     * IntersectionObserver
     * @param {Array} entries - IntersectionObserver entry array
     * @param {IntersectionObserver} observer - the IntersectionObserver itself
     */!
/**
     * setup IntersectionObserver (if available)
     * or start loading all scripts within a `requestAnimationFrame`
     * callback - if available
     */
function(){if(document.querySelectorAll("script").forEach(function(e){c.push(e.src)}),window.IntersectionObserver){var t=new IntersectionObserver(function(e,t){return function(e,t){e.forEach(function(e){e.isIntersecting&&(a(e.target),t.unobserve(e.target))})}(e,t)},e.intersectionObserverOptions);r.forEach(function(e){t.observe(e)})}else window.requestAnimationFrame?window.requestAnimationFrame(function(){return u()}):u()}()}});
